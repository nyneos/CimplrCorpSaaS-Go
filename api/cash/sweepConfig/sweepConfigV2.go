package sweepconfig

import (
	"CimplrCorpSaas/api"
	"CimplrCorpSaas/api/auth"
	"CimplrCorpSaas/api/constants"

	// "context"
	"encoding/json"
	"fmt"
	"net/http"

	// "strconv"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// CreateSweepConfigurationV2 inserts a sweep configuration into sweepconfiguration table and creates a CREATE audit action (PENDING_APPROVAL)
func CreateSweepConfigurationV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID             string   `json:"user_id"`
			EntityName         string   `json:"entity_name"`
			SourceBankName     string   `json:"source_bank_name"`
			SourceBankAccount  string   `json:"source_bank_account"`
			TargetBankName     string   `json:"target_bank_name"`
			TargetBankAccount  string   `json:"target_bank_account"`
			SweepType          string   `json:"sweep_type"` // ZBA, CONCENTRATION, TARGET_BALANCE
			Frequency          string   `json:"frequency"`  // DAILY, MONTHLY, SPECIFIC_DATE
			EffectiveDate      string   `json:"effective_date,omitempty"`
			ExecutionTime      string   `json:"execution_time"`
			BufferAmount       *float64 `json:"buffer_amount,omitempty"`
			SweepAmount        *float64 `json:"sweep_amount,omitempty"`
			RequiresInitiation *bool    `json:"requires_initiation,omitempty"`
			Reason             string   `json:"reason,omitempty"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.RespondWithResult(w, false, constants.ErrInvalidJSONPrefix+err.Error())
			return
		}
		if req.UserID == "" {
			api.RespondWithResult(w, false, constants.ErrUserIDRequired)
			return
		}
		// user_id must match middleware-authenticated user
		if ctxUID := api.GetUserIDFromCtx(ctx); ctxUID != "" && ctxUID != req.UserID {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		// Validate entity / banks / accounts against middleware-provided context
		if strings.TrimSpace(req.EntityName) != "" {
			if !api.IsEntityAllowed(ctx, req.EntityName) {
				api.RespondWithResult(w, false, "unauthorized entity")
				return
			}
		}
		// if strings.TrimSpace(req.SourceBankName) != "" {
		// 	if !api.IsBankAllowed(ctx, req.SourceBankName) {
		// 		api.RespondWithResult(w, false, "unauthorized source bank")
		// 		return
		// 	}
		// }
		// if strings.TrimSpace(req.TargetBankName) != "" {
		// 	if !api.IsBankAllowed(ctx, req.TargetBankName) {
		// 		api.RespondWithResult(w, false, "unauthorized target bank")
		// 		return
		// 	}
		// }
		// if strings.TrimSpace(req.SourceBankAccount) != "" {
		// 	if !ctxHasApprovedBankAccountFor(ctx, req.SourceBankAccount, req.SourceBankName, req.EntityName) {
		// 		api.RespondWithResult(w, false, "unauthorized source bank account")
		// 		return
		// 	}
		// }
		// if strings.TrimSpace(req.TargetBankAccount) != "" {
		// 	if !ctxHasApprovedBankAccountFor(ctx, req.TargetBankAccount, req.TargetBankName, req.EntityName) {
		// 		api.RespondWithResult(w, false, "unauthorized target bank account")
		// 		return
		// 	}
		// }

		// Validate sweep_type (must be ZBA, CONCENTRATION, or TARGET_BALANCE)
		sweepTypeUpper := strings.ToUpper(strings.TrimSpace(req.SweepType))
		if sweepTypeUpper != "ZBA" && sweepTypeUpper != "CONCENTRATION" && sweepTypeUpper != "TARGET_BALANCE" {
			api.RespondWithResult(w, false, "invalid sweep_type. Allowed values: ZBA, CONCENTRATION, TARGET_BALANCE")
			return
		}

		// Validate frequency (must be DAILY, MONTHLY, or SPECIFIC_DATE)
		frequencyUpper := strings.ToUpper(strings.TrimSpace(req.Frequency))
		if frequencyUpper != "DAILY" && frequencyUpper != "MONTHLY" && frequencyUpper != "SPECIFIC_DATE" {
			api.RespondWithResult(w, false, "invalid frequency. Allowed values: DAILY, MONTHLY, SPECIFIC_DATE")
			return
		}

		// resolve requested_by
		requestedBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				requestedBy = s.Name
				break
			}
		}
		if requestedBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		// sweep_id is auto-generated by database DEFAULT, no need to provide it
		ins := `INSERT INTO cimplrcorpsaas.sweepconfiguration (
			entity_name, 
			source_bank_name, source_bank_account, 
			target_bank_name, target_bank_account, 
			sweep_type, frequency, 
			effective_date, execution_time, 
			buffer_amount, sweep_amount, 
			requires_initiation, 
			created_at, updated_at
		) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,now(),now()) RETURNING sweep_id`

		var sweepID string
		err := pgxPool.QueryRow(ctx, ins,
			nullifyEmpty(req.EntityName),
			nullifyEmpty(req.SourceBankName),
			nullifyEmpty(req.SourceBankAccount),
			nullifyEmpty(req.TargetBankName),
			nullifyEmpty(req.TargetBankAccount),
			sweepTypeUpper,
			frequencyUpper,
			nullifyEmpty(req.EffectiveDate),
			nullifyEmpty(req.ExecutionTime),
			nullifyFloat(req.BufferAmount),
			nullifyFloat(req.SweepAmount),
			nullifyBool(req.RequiresInitiation),
		).Scan(&sweepID)

		if err != nil {
			api.RespondWithResult(w, false, "failed to insert sweep configuration: "+err.Error())
			return
		}

		auditQ := `INSERT INTO cimplrcorpsaas.auditactionsweepconfiguration (sweep_id, actiontype, processing_status, reason, requested_by, requested_at) VALUES ($1,'CREATE','PENDING_APPROVAL',$2,$3,now())`
		if _, err := pgxPool.Exec(ctx, auditQ, sweepID, nullifyEmpty(req.Reason), requestedBy); err != nil {
			api.RespondWithResult(w, false, "failed to create audit action: "+err.Error())
			return
		}

		api.RespondWithResult(w, true, sweepID)
	}
}

// BulkCreateSweepConfigurationV2 creates multiple sweep configurations in a single transaction
func BulkCreateSweepConfigurationV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		type SweepConfigRequest struct {
			EntityName         string   `json:"entity_name"`
			SourceBankName     string   `json:"source_bank_name"`
			SourceBankAccount  string   `json:"source_bank_account"`
			TargetBankName     string   `json:"target_bank_name"`
			TargetBankAccount  string   `json:"target_bank_account"`
			SweepType          string   `json:"sweep_type"`
			Frequency          string   `json:"frequency"`
			EffectiveDate      string   `json:"effective_date,omitempty"`
			ExecutionTime      string   `json:"execution_time"`
			BufferAmount       *float64 `json:"buffer_amount,omitempty"`
			SweepAmount        *float64 `json:"sweep_amount,omitempty"`
			RequiresInitiation *bool    `json:"requires_initiation,omitempty"`
			Reason             string   `json:"reason,omitempty"`
		}

		var req struct {
			UserID  string               `json:"user_id"`
			Configs []SweepConfigRequest `json:"configs"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.RespondWithResult(w, false, constants.ErrInvalidJSONPrefix+err.Error())
			return
		}
		if req.UserID == "" {
			api.RespondWithResult(w, false, constants.ErrUserIDRequired)
			return
		}
		if len(req.Configs) == 0 {
			api.RespondWithResult(w, false, "configs array cannot be empty")
			return
		}

		// user_id must match middleware-authenticated user
		if ctxUID := api.GetUserIDFromCtx(ctx); ctxUID != "" && ctxUID != req.UserID {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		// resolve requested_by
		requestedBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				requestedBy = s.Name
				break
			}
		}
		if requestedBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		// Start transaction
		tx, err := pgxPool.Begin(ctx)
		if err != nil {
			api.RespondWithResult(w, false, constants.ErrFailedToBeginTransaction+err.Error())
			return
		}
		committed := false
		defer func() {
			if !committed {
				tx.Rollback(ctx)
			}
		}()

		var createdIDs []string

		for i, cfg := range req.Configs {
			// Validate entity / banks / accounts against middleware-provided context
			if strings.TrimSpace(cfg.EntityName) != "" {
				if !api.IsEntityAllowed(ctx, cfg.EntityName) {
					api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: unauthorized entity %s", i, cfg.EntityName))
					return
				}
			}
			// if strings.TrimSpace(cfg.SourceBankName) != "" {
			// 	if !api.IsBankAllowed(ctx, cfg.SourceBankName) {
			// 		api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: unauthorized source bank %s", i, cfg.SourceBankName))
			// 		return
			// 	}
			// }
			// if strings.TrimSpace(cfg.TargetBankName) != "" {
			// 	if !api.IsBankAllowed(ctx, cfg.TargetBankName) {
			// 		api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: unauthorized target bank %s", i, cfg.TargetBankName))
			// 		return
			// 	}
			// }
			// if strings.TrimSpace(cfg.SourceBankAccount) != "" {
			// 	if !ctxHasApprovedBankAccountFor(ctx, cfg.SourceBankAccount, cfg.SourceBankName, cfg.EntityName) {
			// 		api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: unauthorized source bank account %s", i, cfg.SourceBankAccount))
			// 		return
			// 	}
			// }
			// if strings.TrimSpace(cfg.TargetBankAccount) != "" {
			// 	if !ctxHasApprovedBankAccountFor(ctx, cfg.TargetBankAccount, cfg.TargetBankName, cfg.EntityName) {
			// 		api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: unauthorized target bank account %s", i, cfg.TargetBankAccount))
			// 		return
			// 	}
			// }

			// Validate sweep_type
			sweepTypeUpper := strings.ToUpper(strings.TrimSpace(cfg.SweepType))
			if sweepTypeUpper != "ZBA" && sweepTypeUpper != "CONCENTRATION" && sweepTypeUpper != "TARGET_BALANCE" {
				api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: invalid sweep_type %s", i, cfg.SweepType))
				return
			}

			// Validate frequency
			frequencyUpper := strings.ToUpper(strings.TrimSpace(cfg.Frequency))
			if frequencyUpper != "DAILY" && frequencyUpper != "MONTHLY" && frequencyUpper != "SPECIFIC_DATE" {
				api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: invalid frequency %s", i, cfg.Frequency))
				return
			}

			// Insert sweep configuration
			ins := `INSERT INTO cimplrcorpsaas.sweepconfiguration (
				entity_name, 
				source_bank_name, source_bank_account, 
				target_bank_name, target_bank_account, 
				sweep_type, frequency, 
				effective_date, execution_time, 
				buffer_amount, sweep_amount, 
				requires_initiation, 
				created_at, updated_at
			) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,now(),now()) RETURNING sweep_id`

			var sweepID string
			err := tx.QueryRow(ctx, ins,
				nullifyEmpty(cfg.EntityName),
				nullifyEmpty(cfg.SourceBankName),
				nullifyEmpty(cfg.SourceBankAccount),
				nullifyEmpty(cfg.TargetBankName),
				nullifyEmpty(cfg.TargetBankAccount),
				sweepTypeUpper,
				frequencyUpper,
				nullifyEmpty(cfg.EffectiveDate),
				nullifyEmpty(cfg.ExecutionTime),
				nullifyFloat(cfg.BufferAmount),
				nullifyFloat(cfg.SweepAmount),
				nullifyBool(cfg.RequiresInitiation),
			).Scan(&sweepID)

			if err != nil {
				api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: failed to insert: %s", i, err.Error()))
				return
			}

			// Create audit record
			auditQ := `INSERT INTO cimplrcorpsaas.auditactionsweepconfiguration (sweep_id, actiontype, processing_status, reason, requested_by, requested_at) VALUES ($1,'CREATE','PENDING_APPROVAL',$2,$3,now())`
			if _, err := tx.Exec(ctx, auditQ, sweepID, nullifyEmpty(cfg.Reason), requestedBy); err != nil {
				api.RespondWithResult(w, false, fmt.Sprintf("config[%d]: failed to create audit: %s", i, err.Error()))
				return
			}

			createdIDs = append(createdIDs, sweepID)
		}

		// Commit transaction
		if err := tx.Commit(ctx); err != nil {
			api.RespondWithResult(w, false, constants.ErrTxCommitFailed+err.Error())
			return
		}
		committed = true

		api.RespondWithPayload(w, true, fmt.Sprintf("created %d sweep configurations", len(createdIDs)), map[string]interface{}{
			"sweep_ids": createdIDs,
			"count":     len(createdIDs),
		})
	}
}

// UpdateSweepConfigurationV2 updates allowed fields for a specific sweep_id and creates an EDIT audit (PENDING_EDIT_APPROVAL)
func UpdateSweepConfigurationV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req struct {
			UserID  string                 `json:"user_id"`
			SweepID string                 `json:"sweep_id"`
			Fields  map[string]interface{} `json:"fields"`
			Reason  string                 `json:"reason,omitempty"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.RespondWithResult(w, false, constants.ErrInvalidJSONPrefix+err.Error())
			return
		}
		if req.UserID == "" || req.SweepID == "" {
			api.RespondWithResult(w, false, "user_id and sweep_id required")
			return
		}
		// user_id must match middleware-authenticated user
		ctx := r.Context()
		if ctxUID := api.GetUserIDFromCtx(ctx); ctxUID != "" && ctxUID != req.UserID {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		requestedBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				requestedBy = s.Name
				break
			}
		}
		if requestedBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		tx, err := pgxPool.Begin(ctx)
		if err != nil {
			api.RespondWithResult(w, false, "failed to begin tx: "+err.Error())
			return
		}
		committed := false
		defer func() {
			if !committed {
				tx.Rollback(ctx)
			}
		}()

		sel := `SELECT 
			entity_name, 
			source_bank_name, source_bank_account, 
			target_bank_name, target_bank_account, 
			sweep_type, frequency, 
			effective_date, execution_time, 
			buffer_amount, sweep_amount, 
			requires_initiation 
		FROM cimplrcorpsaas.sweepconfiguration WHERE sweep_id=$1 FOR UPDATE`

		var curEntity, curSourceBank, curSourceAccount, curTargetBank, curTargetAccount, curSweepType, curFrequency sqlNullString
		var curEffectiveDate, curExecutionTime sqlNullString
		var curBufferAmount, curSweepAmount sqlNullFloat
		var curRequiresInitiation *bool

		if err := tx.QueryRow(ctx, sel, req.SweepID).Scan(
			&curEntity,
			&curSourceBank, &curSourceAccount,
			&curTargetBank, &curTargetAccount,
			&curSweepType, &curFrequency,
			&curEffectiveDate, &curExecutionTime,
			&curBufferAmount, &curSweepAmount,
			&curRequiresInitiation,
		); err != nil {
			api.RespondWithResult(w, false, "failed to fetch existing sweep config: "+err.Error())
			return
		}

		sets := []string{}
		args := []interface{}{}
		pos := 1

		addStrField := func(col, oldcol string, val interface{}, cur sqlNullString) {
			sets = append(sets, fmt.Sprintf(constants.FormatSQLSetPair, col, pos, oldcol, pos+1))
			args = append(args, nullifyEmpty(fmt.Sprint(val)))
			args = append(args, cur.ValueOrZero())
			pos += 2
		}
		addFloatField := func(col, oldcol string, val interface{}, cur sqlNullFloat) {
			sets = append(sets, fmt.Sprintf(constants.FormatSQLSetPair, col, pos, oldcol, pos+1))
			if val == nil {
				args = append(args, nil)
			} else {
				args = append(args, val)
			}
			args = append(args, cur.ValueOrZero())
			pos += 2
		}
		addBoolField := func(col, oldcol string, val interface{}, cur *bool) {
			// For boolean fields, we need to handle old_* field differently
			sets = append(sets, fmt.Sprintf("%s=$%d, %s=$%d", col, pos, oldcol, pos+1))
			if val == nil {
				args = append(args, nil)
			} else {
				args = append(args, val)
			}
			if cur == nil {
				args = append(args, nil)
			} else {
				args = append(args, *cur)
			}
			pos += 2
		}

		// track the final values so we can validate accounts against final bank/entity
		finalEntity := strings.TrimSpace(fmt.Sprint(curEntity.ValueOrZero()))
		finalSourceBank := strings.TrimSpace(fmt.Sprint(curSourceBank.ValueOrZero()))
		finalSourceAccount := strings.TrimSpace(fmt.Sprint(curSourceAccount.ValueOrZero()))
		finalTargetBank := strings.TrimSpace(fmt.Sprint(curTargetBank.ValueOrZero()))
		finalTargetAccount := strings.TrimSpace(fmt.Sprint(curTargetAccount.ValueOrZero()))

		for k, v := range req.Fields {
			switch k {
			case "entity_name":
				if s := fmt.Sprint(v); strings.TrimSpace(s) != "" {
					if !api.IsEntityAllowed(ctx, s) {
						api.RespondWithResult(w, false, "unauthorized entity")
						return
					}
				}
				finalEntity = strings.TrimSpace(fmt.Sprint(v))
				addStrField("entity_name", "old_entity_name", v, curEntity)

			case "source_bank_name":
				if s := fmt.Sprint(v); strings.TrimSpace(s) != "" {
					if !api.IsBankAllowed(ctx, s) {
						api.RespondWithResult(w, false, "unauthorized source bank")
						return
					}
				}
				finalSourceBank = strings.TrimSpace(fmt.Sprint(v))
				addStrField("source_bank_name", "old_source_bank_name", v, curSourceBank)

			case "source_bank_account":
				finalSourceAccount = strings.TrimSpace(fmt.Sprint(v))
				addStrField("source_bank_account", "old_source_bank_account", v, curSourceAccount)

			case "target_bank_name":
				if s := fmt.Sprint(v); strings.TrimSpace(s) != "" {
					if !api.IsBankAllowed(ctx, s) {
						api.RespondWithResult(w, false, "unauthorized target bank")
						return
					}
				}
				finalTargetBank = strings.TrimSpace(fmt.Sprint(v))
				addStrField("target_bank_name", "old_target_bank_name", v, curTargetBank)

			case "target_bank_account":
				finalTargetAccount = strings.TrimSpace(fmt.Sprint(v))
				addStrField("target_bank_account", "old_target_bank_account", v, curTargetAccount)

			case "sweep_type":
				// Validate sweep_type
				sweepTypeUpper := strings.ToUpper(strings.TrimSpace(fmt.Sprint(v)))
				if sweepTypeUpper != "ZBA" && sweepTypeUpper != "CONCENTRATION" && sweepTypeUpper != "TARGET_BALANCE" {
					api.RespondWithResult(w, false, "invalid sweep_type. Allowed values: ZBA, CONCENTRATION, TARGET_BALANCE")
					return
				}
				addStrField("sweep_type", "old_sweep_type", sweepTypeUpper, curSweepType)

			case "frequency":
				// Validate frequency
				frequencyUpper := strings.ToUpper(strings.TrimSpace(fmt.Sprint(v)))
				if frequencyUpper != "DAILY" && frequencyUpper != "MONTHLY" && frequencyUpper != "SPECIFIC_DATE" {
					api.RespondWithResult(w, false, "invalid frequency. Allowed values: DAILY, MONTHLY, SPECIFIC_DATE")
					return
				}
				addStrField("frequency", "old_frequency", frequencyUpper, curFrequency)

			case "effective_date":
				addStrField("effective_date", "old_effective_date", v, curEffectiveDate)

			case "execution_time":
				addStrField("execution_time", "old_execution_time", v, curExecutionTime)

			case "buffer_amount":
				addFloatField("buffer_amount", "old_buffer_amount", v, curBufferAmount)

			case "sweep_amount":
				addFloatField("sweep_amount", "old_sweep_amount", v, curSweepAmount)

			case "requires_initiation":
				// Handle boolean field
				if v == nil {
					addBoolField("requires_initiation", "old_requires_initiation", nil, curRequiresInitiation)
				} else {
					boolVal, ok := v.(bool)
					if !ok {
						api.RespondWithResult(w, false, "requires_initiation must be a boolean value")
						return
					}
					addBoolField("requires_initiation", "old_requires_initiation", boolVal, curRequiresInitiation)
				}

			default:
				// ignore unknown fields
			}
		}

		// validate the final accounts match bank/entity and allowed entities
		if strings.TrimSpace(finalSourceAccount) != "" {
			if !ctxHasApprovedBankAccountFor(ctx, finalSourceAccount, finalSourceBank, finalEntity) {
				api.RespondWithResult(w, false, "unauthorized source bank account")
				return
			}
		}
		if strings.TrimSpace(finalTargetAccount) != "" {
			if !ctxHasApprovedBankAccountFor(ctx, finalTargetAccount, finalTargetBank, finalEntity) {
				api.RespondWithResult(w, false, "unauthorized target bank account")
				return
			}
		}

		if len(sets) == 0 {
			api.RespondWithResult(w, false, "no valid fields to update")
			return
		}

		q := "UPDATE cimplrcorpsaas.sweepconfiguration SET " + strings.Join(sets, ", ") + fmt.Sprintf(" WHERE sweep_id=$%d", pos)
		args = append(args, req.SweepID)

		if _, err := tx.Exec(ctx, q, args...); err != nil {
			api.RespondWithResult(w, false, "failed to update sweep config: "+err.Error())
			return
		}

		auditQ := `INSERT INTO cimplrcorpsaas.auditactionsweepconfiguration (sweep_id, actiontype, processing_status, reason, requested_by, requested_at) VALUES ($1,'EDIT','PENDING_EDIT_APPROVAL',$2,$3,now())`
		if _, err := tx.Exec(ctx, auditQ, req.SweepID, nullifyEmpty(req.Reason), requestedBy); err != nil {
			api.RespondWithResult(w, false, "failed to create audit action: "+err.Error())
			return
		}

		if err := tx.Commit(ctx); err != nil {
			api.RespondWithResult(w, false, "failed to commit: "+err.Error())
			return
		}
		committed = true

		api.RespondWithResult(w, true, req.SweepID)
	}
}

// GetSweepConfigurationsV2 returns sweepconfiguration rows with latest audit info
func GetSweepConfigurationsV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID string `json:"user_id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.RespondWithResult(w, false, constants.ErrInvalidJSONPrefix+err.Error())
			return
		}
		if req.UserID == "" {
			api.RespondWithResult(w, false, "Missing user_id in body")
			return
		}
		// user_id must match middleware-authenticated user
		if ctxUID := api.GetUserIDFromCtx(ctx); ctxUID != "" && ctxUID != req.UserID {
			api.RespondWithResult(w, false, constants.ErrInvalidSessionCapitalized)
			return
		}

		// validate session
		valid := false
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				valid = true
				break
			}
		}
		if !valid {
			api.RespondWithResult(w, false, constants.ErrInvalidSessionCapitalized)
			return
		}

		// skip soft-deleted rows
		entityNames := api.GetEntityNamesFromCtx(ctx)
		var rows pgx.Rows
		var err error
		if len(entityNames) > 0 {
			// normalize entity names (trim + lower) and compare against lower(trim(entity_name)) in DB
			norm := make([]string, 0, len(entityNames))
			for _, n := range entityNames {
				if s := strings.TrimSpace(n); s != "" {
					norm = append(norm, strings.ToLower(s))
				}
			}
			if len(norm) == 0 {
				// nothing allowed
				api.RespondWithPayload(w, true, "", []map[string]interface{}{})
				return
			}
			q := `SELECT 
								sweep_id, entity_name, 
								source_bank_name, source_bank_account, 
								target_bank_name, target_bank_account, 
								sweep_type, frequency,
								-- include latest approved balances (0 if none)
								COALESCE(bbal1.current_balance,0) AS source_current_balance,
								COALESCE(bbal2.current_balance,0) AS target_current_balance,
								effective_date, execution_time, 
								buffer_amount, sweep_amount, 
								requires_initiation,
								old_entity_name, 
								old_source_bank_name, old_source_bank_account, 
								old_target_bank_name, old_target_bank_account, 
								old_sweep_type, old_frequency, 
								old_effective_date, old_execution_time, 
								old_buffer_amount, old_sweep_amount
						FROM cimplrcorpsaas.sweepconfiguration 
						LEFT JOIN LATERAL (
								SELECT COALESCE(bbm.closing_balance,0) AS current_balance
								FROM public.bank_balances_manual bbm
								JOIN public.auditactionbankbalances a ON a.balance_id = bbm.balance_id
								WHERE a.processing_status = 'APPROVED'
									AND bbm.account_no = COALESCE(sweepconfiguration.source_bank_account, sweepconfiguration.source_bank_account)
								ORDER BY bbm.as_of_date DESC, bbm.as_of_time DESC, a.requested_at DESC
								LIMIT 1
						) bbal1 ON true
						LEFT JOIN LATERAL (
								SELECT COALESCE(bbm.closing_balance,0) AS current_balance
								FROM public.bank_balances_manual bbm
								JOIN public.auditactionbankbalances a ON a.balance_id = bbm.balance_id
								WHERE a.processing_status = 'APPROVED'
									AND bbm.account_no = COALESCE(sweepconfiguration.target_bank_account, sweepconfiguration.target_bank_account)
								ORDER BY bbm.as_of_date DESC, bbm.as_of_time DESC, a.requested_at DESC
								LIMIT 1
						) bbal2 ON true
						WHERE is_deleted != TRUE AND lower(trim(entity_name)) = ANY($1) 
						ORDER BY created_at DESC, sweep_id`
			rows, err = pgxPool.Query(ctx, q, norm)
		} else {
			q := `SELECT 
								sweep_id, entity_name, 
								source_bank_name, source_bank_account, 
								target_bank_name, target_bank_account, 
								sweep_type, frequency,
								-- include latest approved balances (0 if none)
								COALESCE(bbal1.current_balance,0) AS source_current_balance,
								COALESCE(bbal2.current_balance,0) AS target_current_balance,
								effective_date, execution_time, 
								buffer_amount, sweep_amount, 
								requires_initiation,
								old_entity_name, 
								old_source_bank_name, old_source_bank_account, 
								old_target_bank_name, old_target_bank_account, 
								old_sweep_type, old_frequency, 
								old_effective_date, old_execution_time, 
								old_buffer_amount, old_sweep_amount
						FROM cimplrcorpsaas.sweepconfiguration 
						LEFT JOIN LATERAL (
								SELECT COALESCE(bbm.closing_balance,0) AS current_balance
								FROM public.bank_balances_manual bbm
								JOIN public.auditactionbankbalances a ON a.balance_id = bbm.balance_id
								WHERE a.processing_status = 'APPROVED'
									AND bbm.account_no = COALESCE(sweepconfiguration.source_bank_account, sweepconfiguration.source_bank_account)
								ORDER BY bbm.as_of_date DESC, bbm.as_of_time DESC, a.requested_at DESC
								LIMIT 1
						) bbal1 ON true
						LEFT JOIN LATERAL (
								SELECT COALESCE(bbm.closing_balance,0) AS current_balance
								FROM public.bank_balances_manual bbm
								JOIN public.auditactionbankbalances a ON a.balance_id = bbm.balance_id
								WHERE a.processing_status = 'APPROVED'
									AND bbm.account_no = COALESCE(sweepconfiguration.target_bank_account, sweepconfiguration.target_bank_account)
								ORDER BY bbm.as_of_date DESC, bbm.as_of_time DESC, a.requested_at DESC
								LIMIT 1
						) bbal2 ON true
						WHERE is_deleted != TRUE 
						ORDER BY created_at DESC, sweep_id`
			rows, err = pgxPool.Query(ctx, q)
		}
		if err != nil {
			api.RespondWithResult(w, false, constants.ErrDBPrefix+err.Error())
			return
		}
		defer rows.Close()

		out := make([]map[string]interface{}, 0)
		for rows.Next() {
			var sweepID string
			var entity, sourceBank, sourceAccount, targetBank, targetAccount, sweepType, freq sqlNullString
			var sourceCurrBal, targetCurrBal sqlNullFloat
			var effectiveDate, execTime sqlNullString
			var bufferAmt, sweepAmt sqlNullFloat
			var requiresInitiation *bool
			var oldEntity, oldSourceBank, oldSourceAccount, oldTargetBank, oldTargetAccount, oldSweepType, oldFreq sqlNullString
			var oldEffectiveDate, oldExecTime sqlNullString
			var oldBufferAmt, oldSweepAmt sqlNullFloat

			if err := rows.Scan(
				&sweepID, &entity,
				&sourceBank, &sourceAccount,
				&targetBank, &targetAccount,
				&sweepType, &freq,
				&sourceCurrBal, &targetCurrBal,
				&effectiveDate, &execTime,
				&bufferAmt, &sweepAmt,
				&requiresInitiation,
				&oldEntity,
				&oldSourceBank, &oldSourceAccount,
				&oldTargetBank, &oldTargetAccount,
				&oldSweepType, &oldFreq,
				&oldEffectiveDate, &oldExecTime,
				&oldBufferAmt, &oldSweepAmt,
			); err != nil {
				continue
			}

			auditLatest := `SELECT processing_status, requested_by, requested_at, actiontype, action_id, checker_by, checker_at, checker_comment, reason FROM cimplrcorpsaas.auditactionsweepconfiguration WHERE sweep_id = $1 ORDER BY requested_at DESC LIMIT 1`
			var processingStatusPtr, requestedByPtr, actionTypePtr, actionIDPtr, checkerByPtr, checkerCommentPtr, reasonPtr *string
			var requestedAtPtr, checkerAtPtr *time.Time
			_ = pgxPool.QueryRow(ctx, auditLatest, sweepID).Scan(&processingStatusPtr, &requestedByPtr, &requestedAtPtr, &actionTypePtr, &actionIDPtr, &checkerByPtr, &checkerAtPtr, &checkerCommentPtr, &reasonPtr)

			// Then fetch recent CREATE/EDIT/DELETE entries to build created/edited/deleted summary
			auditDetailsQuery := `SELECT actiontype, requested_by, requested_at FROM cimplrcorpsaas.auditactionsweepconfiguration WHERE sweep_id = $1 AND actiontype IN ('CREATE','EDIT','DELETE') ORDER BY requested_at DESC`
			auditRows, auditErr := pgxPool.Query(ctx, auditDetailsQuery, sweepID)
			var createdBy, createdAt, editedBy, editedAt, deletedBy, deletedAt string
			if auditErr == nil {
				defer auditRows.Close()
				for auditRows.Next() {
					var atype string
					var rbyPtr *string
					var ratPtr *time.Time
					if err := auditRows.Scan(&atype, &rbyPtr, &ratPtr); err == nil {
						auditInfo := api.GetAuditInfo(atype, rbyPtr, ratPtr)
						if atype == "CREATE" && createdBy == "" {
							createdBy = auditInfo.CreatedBy
							createdAt = auditInfo.CreatedAt
						} else if atype == "EDIT" && editedBy == "" {
							editedBy = auditInfo.EditedBy
							editedAt = auditInfo.EditedAt
						} else if atype == "DELETE" && deletedBy == "" {
							deletedBy = auditInfo.DeletedBy
							deletedAt = auditInfo.DeletedAt
						}
					}
				}
			}

			// apply context-level filters for banks and accounts
			sourceBankStr := fmt.Sprint(sourceBank.ValueOrZero())
			targetBankStr := fmt.Sprint(targetBank.ValueOrZero())
			sourceAccountStr := fmt.Sprint(sourceAccount.ValueOrZero())
			targetAccountStr := fmt.Sprint(targetAccount.ValueOrZero())

			if sourceBankStr != "" {
				if !api.IsBankAllowed(ctx, sourceBankStr) {
					continue
				}
			}
			if targetBankStr != "" {
				if !api.IsBankAllowed(ctx, targetBankStr) {
					continue
				}
			}
			if sourceAccountStr != "" {
				if !ctxHasApprovedBankAccount(ctx, sourceAccountStr) {
					continue
				}
			}
			if targetAccountStr != "" {
				if !ctxHasApprovedBankAccount(ctx, targetAccountStr) {
					continue
				}
			}

			m := map[string]interface{}{
				"sweep_id":                sweepID,
				"entity_name":             entity.ValueOrZero(),
				"source_bank_name":        sourceBank.ValueOrZero(),
				"source_bank_account":     sourceAccount.ValueOrZero(),
				"target_bank_name":        targetBank.ValueOrZero(),
				"target_bank_account":     targetAccount.ValueOrZero(),
				"sweep_type":              sweepType.ValueOrZero(),
				"frequency":               freq.ValueOrZero(),
				"effective_date":          effectiveDate.ValueOrZero(),
				"execution_time":          execTime.ValueOrZero(),
				"source_current_balance":  sourceCurrBal.ValueOrZero(),
				"target_current_balance":  targetCurrBal.ValueOrZero(),
				"buffer_amount":           bufferAmt.ValueOrZero(),
				"sweep_amount":            sweepAmt.ValueOrZero(),
				"requires_initiation":     requiresInitiation,
				"old_entity_name":         oldEntity.ValueOrZero(),
				"old_source_bank_name":    oldSourceBank.ValueOrZero(),
				"old_source_bank_account": oldSourceAccount.ValueOrZero(),
				"old_target_bank_name":    oldTargetBank.ValueOrZero(),
				"old_target_bank_account": oldTargetAccount.ValueOrZero(),
				"old_sweep_type":          oldSweepType.ValueOrZero(),
				"old_frequency":           oldFreq.ValueOrZero(),
				"old_effective_date":      oldEffectiveDate.ValueOrZero(),
				"old_execution_time":      oldExecTime.ValueOrZero(),
				"old_buffer_amount":       oldBufferAmt.ValueOrZero(),
				"old_sweep_amount":        oldSweepAmt.ValueOrZero(),
				"processing_status": func() string {
					if processingStatusPtr != nil {
						return *processingStatusPtr
					}
					return ""
				}(),
				"action_type": func() string {
					if actionTypePtr != nil {
						return *actionTypePtr
					}
					return ""
				}(),
				"action_id": func() string {
					if actionIDPtr != nil {
						return *actionIDPtr
					}
					return ""
				}(),
				"checker_by": api.GetAuditInfo("", checkerByPtr, checkerAtPtr).CreatedBy,
				"checker_at": api.GetAuditInfo("", checkerByPtr, checkerAtPtr).CreatedAt,
				"checker_comment": func() string {
					if checkerCommentPtr != nil {
						return *checkerCommentPtr
					}
					return ""
				}(),
				"reason": func() string {
					if reasonPtr != nil {
						return *reasonPtr
					}
					return ""
				}(),
				"created_by": createdBy,
				"created_at": createdAt,
				"edited_by":  editedBy,
				"edited_at":  editedAt,
				"deleted_by": deletedBy,
				"deleted_at": deletedAt,
			}
			out = append(out, m)
		}
		if rows.Err() != nil {
			api.RespondWithResult(w, false, "DB rows error: "+rows.Err().Error())
			return
		}

		api.RespondWithPayload(w, true, "", out)
	}
}

// BulkApproveSweepConfigurationsV2 approves pending audit actions for given sweep_ids (V2 table)
func BulkApproveSweepConfigurationsV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID   string   `json:"user_id"`
			SweepIDs []string `json:"sweep_ids"`
			Comment  string   `json:"comment,omitempty"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.UserID == "" || len(req.SweepIDs) == 0 {
			api.RespondWithResult(w, false, constants.ErrInvalidJSON)
			return
		}
		checkerBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				checkerBy = s.Name
				break
			}
		}
		if checkerBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		sel := `SELECT DISTINCT ON (sweep_id) action_id, sweep_id, actiontype FROM cimplrcorpsaas.auditactionsweepconfiguration WHERE sweep_id = ANY($1) ORDER BY sweep_id, requested_at DESC`
		rows, err := pgxPool.Query(ctx, sel, req.SweepIDs)
		if err != nil {
			api.RespondWithResult(w, false, "failed to fetch latest audits: "+err.Error())
			return
		}
		defer rows.Close()

		actionIDs := make([]string, 0)
		deleteIDs := make([]string, 0)
		found := map[string]bool{}
		for rows.Next() {
			var actionID, sweepID, actionType string
			if err := rows.Scan(&actionID, &sweepID, &actionType); err != nil {
				continue
			}
			found[sweepID] = true
			actionIDs = append(actionIDs, actionID)
			if actionType == "DELETE" {
				deleteIDs = append(deleteIDs, sweepID)
			}
		}

		missing := []string{}
		for _, id := range req.SweepIDs {
			if !found[id] {
				missing = append(missing, id)
			}
		}
		if len(missing) > 0 {
			api.RespondWithResult(w, false, fmt.Sprintf("missing audit entries for: %v", missing))
			return
		}

		upd := `UPDATE cimplrcorpsaas.auditactionsweepconfiguration SET processing_status='APPROVED', checker_by=$1, checker_at=now(), checker_comment=$2 WHERE action_id = ANY($3)`
		if _, err := pgxPool.Exec(ctx, upd, checkerBy, nullifyEmpty(req.Comment), actionIDs); err != nil {
			api.RespondWithResult(w, false, "failed to approve actions: "+err.Error())
			return
		}

		deleted := []string{}
		if len(deleteIDs) > 0 {
			// perform soft-delete
			updDel := `UPDATE cimplrcorpsaas.sweepconfiguration SET is_deleted = TRUE, updated_at = now() WHERE sweep_id = ANY($1) RETURNING sweep_id`
			drows, derr := pgxPool.Query(ctx, updDel, deleteIDs)
			if derr == nil {
				defer drows.Close()
				for drows.Next() {
					var id string
					drows.Scan(&id)
					deleted = append(deleted, id)
				}
			}
		}

		api.RespondWithPayload(w, true, "", map[string]interface{}{"approved_count": len(actionIDs), "deleted": deleted})
	}
}

// BulkRejectSweepConfigurationsV2 rejects latest audit actions for given sweep_ids (V2 table)
func BulkRejectSweepConfigurationsV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID   string   `json:"user_id"`
			SweepIDs []string `json:"sweep_ids"`
			Comment  string   `json:"comment"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.UserID == "" || len(req.SweepIDs) == 0 {
			api.RespondWithResult(w, false, constants.ErrInvalidJSON)
			return
		}
		checkerBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				checkerBy = s.Name
				break
			}
		}
		if checkerBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		sel := `SELECT DISTINCT ON (sweep_id) action_id, sweep_id FROM cimplrcorpsaas.auditactionsweepconfiguration WHERE sweep_id = ANY($1) ORDER BY sweep_id, requested_at DESC`
		rows, err := pgxPool.Query(ctx, sel, req.SweepIDs)
		if err != nil {
			api.RespondWithResult(w, false, "failed to fetch latest audits: "+err.Error())
			return
		}
		defer rows.Close()

		actionIDs := make([]string, 0)
		found := map[string]bool{}
		for rows.Next() {
			var actionID, sweepID string
			if err := rows.Scan(&actionID, &sweepID); err != nil {
				continue
			}
			found[sweepID] = true
			actionIDs = append(actionIDs, actionID)
		}
		missing := []string{}
		for _, id := range req.SweepIDs {
			if !found[id] {
				missing = append(missing, id)
			}
		}
		if len(missing) > 0 {
			api.RespondWithResult(w, false, fmt.Sprintf("missing audit entries for: %v", missing))
			return
		}

		upd := `UPDATE cimplrcorpsaas.auditactionsweepconfiguration SET processing_status='REJECTED', checker_by=$1, checker_at=now(), checker_comment=$2 WHERE action_id = ANY($3)`
		if _, err := pgxPool.Exec(ctx, upd, checkerBy, nullifyEmpty(req.Comment), actionIDs); err != nil {
			api.RespondWithResult(w, false, "failed to reject actions: "+err.Error())
			return
		}

		api.RespondWithPayload(w, true, "", map[string]interface{}{"rejected_count": len(actionIDs)})
	}
}

// BulkRequestDeleteSweepConfigurationsV2 inserts DELETE audit actions (PENDING_DELETE_APPROVAL) for sweep configs (V2 table)
func BulkRequestDeleteSweepConfigurationsV2(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID   string   `json:"user_id"`
			SweepIDs []string `json:"sweep_ids"`
			Reason   string   `json:"reason"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.UserID == "" || len(req.SweepIDs) == 0 {
			api.RespondWithResult(w, false, constants.ErrInvalidJSON)
			return
		}
		requestedBy := ""
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				requestedBy = s.Name
				break
			}
		}
		if requestedBy == "" {
			api.RespondWithResult(w, false, constants.ErrInvalidSession)
			return
		}

		tx, err := pgxPool.Begin(ctx)
		if err != nil {
			api.RespondWithResult(w, false, "failed to begin tx: "+err.Error())
			return
		}
		committed := false
		defer func() {
			if !committed {
				tx.Rollback(ctx)
			}
		}()

		ins := `INSERT INTO cimplrcorpsaas.auditactionsweepconfiguration (sweep_id, actiontype, processing_status, reason, requested_by, requested_at) VALUES ($1,'DELETE','PENDING_DELETE_APPROVAL',$2,$3,now())`
		for _, id := range req.SweepIDs {
			if _, err := tx.Exec(ctx, ins, id, nullifyEmpty(req.Reason), requestedBy); err != nil {
				api.RespondWithResult(w, false, "failed to create delete audit: "+err.Error())
				return
			}
		}
		if err := tx.Commit(ctx); err != nil {
			api.RespondWithResult(w, false, "failed to commit: "+err.Error())
			return
		}
		committed = true

		api.RespondWithResult(w, true, fmt.Sprintf("created %d delete requests", len(req.SweepIDs)))
	}
}

// GetApprovedActiveSweepConfigurations returns only APPROVED and ACTIVE sweep configurations
func GetApprovedActiveSweepConfigurations(pgxPool *pgxpool.Pool) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		var req struct {
			UserID string `json:"user_id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.RespondWithResult(w, false, constants.ErrInvalidJSONPrefix+err.Error())
			return
		}
		if req.UserID == "" {
			api.RespondWithResult(w, false, "Missing user_id in body")
			return
		}
		// user_id must match middleware-authenticated user
		if ctxUID := api.GetUserIDFromCtx(ctx); ctxUID != "" && ctxUID != req.UserID {
			api.RespondWithResult(w, false, constants.ErrInvalidSessionCapitalized)
			return
		}

		// validate session
		valid := false
		for _, s := range auth.GetActiveSessions() {
			if s.UserID == req.UserID {
				valid = true
				break
			}
		}
		if !valid {
			api.RespondWithResult(w, false, constants.ErrInvalidSessionCapitalized)
			return
		}

		// Get entity filter
		entityNames := api.GetEntityNamesFromCtx(ctx)
		norm := make([]string, 0, len(entityNames))
		for _, n := range entityNames {
			if s := strings.TrimSpace(n); s != "" {
				norm = append(norm, strings.ToLower(s))
			}
		}

		var rows pgx.Rows
		var err error

		// Query only APPROVED configurations that are ACTIVE (is_deleted = false)
		// Filter out sweeps that already have APPROVED initiations
		q := `
			SELECT DISTINCT ON (sc.sweep_id)
				sc.sweep_id, 
				sc.entity_name, 
				sc.source_bank_name, 
				sc.source_bank_account, 
				sc.target_bank_name, 
				sc.target_bank_account, 
				sc.sweep_type, 
				sc.frequency, 
				sc.effective_date, 
				sc.execution_time, 
				sc.buffer_amount, 
				sc.sweep_amount, 
				sc.requires_initiation,
				sc.created_at
			FROM cimplrcorpsaas.sweepconfiguration sc
			JOIN cimplrcorpsaas.auditactionsweepconfiguration a 
				ON a.sweep_id = sc.sweep_id
			WHERE sc.is_deleted = false 
				AND a.processing_status = 'APPROVED'
				AND NOT EXISTS (
					SELECT 1 FROM cimplrcorpsaas.sweep_initiation si
					JOIN cimplrcorpsaas.auditactionsweepinitiation asi 
						ON asi.initiation_id = si.initiation_id
					WHERE si.sweep_id = sc.sweep_id 
				)
		`

		if len(norm) > 0 {
			q += ` AND lower(trim(sc.entity_name)) = ANY($1)`
			q += ` ORDER BY sc.sweep_id, a.requested_at DESC`
			rows, err = pgxPool.Query(ctx, q, norm)
		} else {
			q += ` ORDER BY sc.sweep_id, a.requested_at DESC`
			rows, err = pgxPool.Query(ctx, q)
		}

		if err != nil {
			api.RespondWithResult(w, false, constants.ErrDBPrefix+err.Error())
			return
		}
		defer rows.Close()

		out := make([]map[string]interface{}, 0)
		for rows.Next() {
			var sweepID string
			var entity, sourceBank, sourceAccount, targetBank, targetAccount, sweepType, freq sqlNullString
			var effectiveDate, execTime sqlNullString
			var bufferAmt, sweepAmt sqlNullFloat
			var requiresInitiation *bool
			var createdAt time.Time

			if err := rows.Scan(
				&sweepID, &entity,
				&sourceBank, &sourceAccount,
				&targetBank, &targetAccount,
				&sweepType, &freq,
				&effectiveDate, &execTime,
				&bufferAmt, &sweepAmt,
				&requiresInitiation,
				&createdAt,
			); err != nil {
				api.RespondWithResult(w, false, constants.ErrDBPrefix+err.Error())
				return
			}

			m := map[string]interface{}{
				"sweep_id":            sweepID,
				"entity_name":         entity.ValueOrZero(),
				"source_bank_name":    sourceBank.ValueOrZero(),
				"source_bank_account": sourceAccount.ValueOrZero(),
				"target_bank_name":    targetBank.ValueOrZero(),
				"target_bank_account": targetAccount.ValueOrZero(),
				"sweep_type":          sweepType.ValueOrZero(),
				"frequency":           freq.ValueOrZero(),
				"effective_date":      effectiveDate.ValueOrZero(),
				"execution_time":      execTime.ValueOrZero(),
				"buffer_amount":       bufferAmt.ValueOrZero(),
				"sweep_amount":        sweepAmt.ValueOrZero(),
				"requires_initiation": requiresInitiation,
				"created_at":          createdAt,
			}
			out = append(out, m)
		}

		if rows.Err() != nil {
			api.RespondWithResult(w, false, constants.ErrDBPrefix+rows.Err().Error())
			return
		}

		api.RespondWithPayload(w, true, "", out)
	}
}
